# React hooksとは
React 16.8にて追加された機能で、ステートの再利用などにテクニックが必要で、
テクニックを使ったがためにコンポーネントが複雑化するのを回避するために作られた。
ある実装したい機能に対するコードが様々なライフサイクルメソッドなどの場所に混在していたのを、
機能に基づいた関数分割ができるよう一新したらしい。

より具体的には、クラスコンポーネントがステートなどReactの機能の利用権を牛耳っていたReact界で、
フックを利用することでReactの機能を関数コンポーネントにも導入する。
フックは規則として`useHoge()`の形式で命名されており、
ユーザが作成する独自のフックもそのように命名するよう奨励されている。

参照: https://ja.reactjs.org/docs/hooks-overview.html

# ビルトインフック
React側からいくつか主要なフックは組み込んで提供されている。

## ステートフック
関数コンポーネントにステートを導入するためのフック。
`useState()`関数によって定義され、[ステート, ステートのセッター]で構成されるリストが返る。
ふつうは分割代入を利用し、`const [hoge, setHoge] = useState("fuga")`のようにリストを受ける。
引数にはステートの初期値としたい値を入れる。

参照: https://ja.reactjs.org/docs/hooks-state.html

```React
const FncCmp = (props) => {
    const [st, setSt] = useState(0);

    return (
        <div>
            <p>
                st: {st}
                <button onClick={() => setSt(st + 1)}>
                    increase st
                </button>
            </p>
        </div>
    );
}

class ClsCmp extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            st: 0
        };
    }
    render() {
        return (
            <div>
                <p>
                    st: {st}
                    <button onClick={() => this.setState(st: this.state.st + 1)}>
                        increase st
                    </button>
                </p>
            </div>
        );
    }
}
```

前者がステートフックを利用した関数コンポーネントによるステート利用、
後者が従来のクラスコンポーネントによるステート利用となっている。
この例では関数コンポーネントの方が手続き的だが、
それ以上にthisを利用することなく単なる変数のように簡潔にステートの読み書きをしている。

この例では触れていないが、記述だけでなく機能的な違いが1点ある。
ステートを更新する際の挙動はクラスコンポーネントであればマージするが、
関数コンポーネントでは置換する。
複数のステートを並行して管理する際にこの問題が顕在化する場合がある。
まずクラスコンポーネントでは必然的に一つのオブジェクトに複数のステートを格納する。
```
state: {
    a: 1,
    b: 2,
    c: 3
}
```
ここでbを10に変更したくなった場合は、単純に
`this.setState(b: 10);`とすればよい。

一方、関数コンポーネントでこれらのステートを一つのオブジェクトとしてステート変数に保存した場合はこのようになるが、
```
const [stObj, setStObj] = useState({
    a: 1,
    b: 2,
    c: 3
});
```
このうち同様にbのみを10に変更したくなった場合、a, cを置換で殺してしまわないよう、
`setStObj(stObj => ({...stObj, b: 10}));`
というように、更新したい値以外にも気を遣った書き方が必要になる。
`...stObj`と記述しておくことで明示的に指定していない値はそのまま代入してくれるようになるので、
これを利用すれば更新したい値以外を全て書き連ねる必要はなくなるが、それでもある程度は手間になる。

※ここでset関数の引数に、更新後の値ではなく更新の処理を記述する関数を入れているが、
元々の値を利用して新規の値を計算する際にはこのように関数を渡すのが好ましいようだ。
この関数の引数には更新前の値が入り、戻り値が新規の値となる。
しかし紹介時に書いたようにset関数に直接ステートを入れて計算を記述することもできるので、
こちらの利点はよくわからない。
set関数のみを渡して更新することがあるからだろうか？あるいはパフォーマンス上の問題か。

しかしこれを解決するためにもステートフックではステート変数の分割がすることができる。
今回の例ではa, b, cを別個のステート変数として持てば、個別の更新も難なく行える。
```
const [stA, setStA] = useState(1);
const [stB, setStB] = useState(2);
const [stC, setStC] = useState(3);
```
このように3つのステート変数を独立して管理するようにしておけば、
同様にbのみを10に変えたい場合は
`setStB(10)`と記述するだけで済む。
通常のオブジェクトでも同じことが言えるが、同時に値を変更するようなものだけを
オブジェクトにまとめておくべき。

## 副作用フック
そもそも副作用という言葉がなんともわかりにくい。
意味としては「関数の外のものにも影響を及ぼす処理」のことを指す。
つまり、その関数の中でのみ管理しているもの*以外の*データに触れるような処理のこと。
今回の関数コンポーネントはレンダリングの処理を書く(DOMを構築する)役割だけを持つべきなので、
既存のDOMをいじったりAPIでデータを取得したり、果てはステートを更新するべきではない。
実際、ステートを下手に更新するとステート更新→再レンダリング→ステート更新→…の無限ループに陥る。

参照:
https://www.hypertextcandy.com/react-tutorial-06-effect
https://ja.reactjs.org/docs/hooks-state.html

関数コンポーネントの内部にそうした処理を書くわけにはいかないので、
それを書くためのものが副作用フックであり、`useEffect()`を利用する。

実際のところ、副作用フックを利用するとrender()によって描画した後に処理を挟むことができる。
これはクラスコンポーネントでは`componentDidMount()`や`componentDidUpdate()`によって実現されていたもの。

また、こちらもステートフックと同様に複数の`useEffect()`に処理を分割することができ、
これによって従来のライフサイクル内にごちゃ混ぜになっていた処理を、
関数のトップレベルで機能ごとにまとめられるようになっている。

例えば、stateによって動的にページのタイトル(これはrenderの範疇ではない)を変更したいときは、

```
useEffect(() -> {
    document.title = `st: ${st}`;
});
```
のように記述すれば変更することができる。
これがもしクラスコンポーネントであれば、次のような記述が必要になる。

```
componentDidMount(){
    document.title = `st: ${this.state.st}`;
}
componentDidUpdate(){
    document.title = `st: ${this.state.st}`;
}
```
関数コンポーネントwith副作用フックに比べると、このように随時更新したい場合はやや冗長になる。
一見その分クラスコンポーネントによる方法の方が段階を分けることができて自由度が高そうに見えるが、
`useEffect()`も与える引数によってその挙動をカスタマイズすることができる。

### 処理タイミングの制限
`useEffect()`の第二引数にはリストを入れることができるが、
このリスト内にある値が一つでも前回のレンダリングから変化している場合のみ副作用を実行するようにできる。
逆に、初回のみ動作させたいときはこの仕様を利用し、第二引数に空のリストを入れればよい。

より現実的には、与えられたpropsやコンポーネント内部のstateが変化したとき、
その変更だけをリアルタイムに反映したい場合や、処理の回数や条件を制限したい場合に有効になる。
他にも、副作用の処理タイミングを制限することでパフォーマンスを高めたい場合に利用することになる。
こちらについてはクリーンアップの項で後述する。

### 副作用のクリーンアップ
クラスコンポーネントで言うところの`componentWillUnmount()`で実現されていた機能が副作用フックでも利用でき、
`useEffect()`に渡した関数に戻り値として関数を指定しておくと、
アンマウントされる際、デストラクタのようにその戻り値に設定した関数が実行される。
この関数では副作用によって引き起こされうるメモリリークなどを解決するための処理を入れることがあり、
そういった処理にちなんで戻り値の関数に入れる処理をクリーンアップと呼ぶ。

さらに、`componentWillUnmount()`とは異なり、
デフォルトでは2回目以降のレンダリング時、その回の副作用を実行する前にクリーンアップを実行する。
この仕様がなければ、レンダリング間で副作用に使う値に何か変更があった場合などで、
その回と前回のレンダリングで処理が噛み合わなくなってしまう可能性がある(React公式docに例示あり)。
自動的に前回のレンダリング時に起こした副作用をクリーンアップすることで、その回の副作用を独立したものにして
動作を安定させる狙いがあるということ。
無論、クリーンアップの内容を適切に記述しなければ前回の副作用をクリーンアップできないので、
クリーンアップが必要な場合は前回のレンダリングによる副作用をクリーンアップできるよう処理を設計する必要がある。

処理タイミングの制限の項で解説した第二引数にリストを入れることを利用すると、
クリーンアップもまた第二引数で制限した通りのタイミングで実行される。
`useEffect()`内の副作用を起こす関数はマウント時、および第二引数内の要素が変更されたときにのみ実行され、
その戻り値に設定されたクリーンアップのための関数は、アンマウント時および前述の
「副作用を持つ関数が第二引数内の要素が変更されたときにのみ実行される」タイミングの直前に実行される。

